# Cursor Rules

**‚ö†Ô∏è IMPORTANT: This file has been updated to reflect the current CUSTOM Rust migration system.**
**Old sqlx-specific rules have been replaced with our custom `cargo run --bin migrate --` commands.**

---

# üö® CRITICAL QUICK REFERENCE

## PRODUCTION DATABASE (NEVER FORGET!)
- **Location**: `src-tauri/db/stocks.db` (2.5GB PRODUCTION DATABASE)
- **Size**: 2.5GB with S&P 500 financial data
- **Status**: PRODUCTION - contains all valuable data
- **Stats**: 5,892 stocks, 6.5M+ price records, 142K+ financial records

## WORKING DIRECTORY
**ALWAYS**: `/Users/yksoni/code/misc/rust-stocks` (ROOT)

## üîß DATABASE MIGRATIONS (CRITICAL)
**‚ö†Ô∏è We use a CUSTOM Rust migration tool, NOT sqlx directly!**

**Environment setup (REQUIRED):**
```bash
export PROJECT_ROOT=/Users/yksoni/code/misc/rust-stocks
cd $PROJECT_ROOT/src-tauri
```

**Migration commands:**
```bash
# Create new migration
cargo run --bin migrate -- create <description>

# Apply migrations
cargo run --bin migrate -- run

# Check status
cargo run --bin migrate -- status

# Revert last migration
cargo run --bin migrate -- revert
```

**Database admin:**
```bash
# Check database status (ALWAYS run first)
cargo run --bin db_admin -- status

# Run migrations with safety (production)
cargo run --bin db_admin -- migrate --confirm
```

## üö´ NEVER DO THESE THINGS
- ‚ùå Look for database in ROOT - it's in `src-tauri/db/stocks.db`
- ‚ùå Put migrations in root - they belong in `src-tauri/db/migrations/`
- ‚ùå Confuse frontend (src/) with backend (src-tauri/src/)
- ‚ùå Use old `sqlx migrate` commands - we have a custom tool now
- ‚ùå Run migrations without setting PROJECT_ROOT environment variable
- ‚ùå Modify migration files after they've been applied
- ‚ùå Use hardcoded database paths - always use environment variables
- ‚ùå Change API contracts without checking both sides

---

# üìã DETAILED TECHNICAL RULES


## Project Structure Rules
- Working directory is ALWAYS ROOT: `/Users/yksoni/code/misc/rust-stocks`
- Frontend is in `src/` (SolidJS TypeScript components)
- Backend is in `src-tauri/src/` (Rust code)
- Database is in `src-tauri/db/stocks.db` (2.5GB PRODUCTION DATABASE)
- Migrations are in `src-tauri/db/migrations/`
- Backups are in `src-tauri/db/backups/`
- most project context is in .md files in 'context/'
- NEVER put .md files randomly in the project root - they belong in the context/ folder


## Database Rules
- CRITICAL: Database changes MUST use our CUSTOM Rust migration tool, NOT sqlx directly.
  - NEVER run direct SQL (ALTER TABLE/UPDATE/CREATE/DROP) against the DB from the terminal or ad-hoc scripts.
  - Use the custom migration tool: `cargo run --bin migrate --`
  - Check context/DATABASE_MIGRATIONS.md to fully understand the migrations feature
  - Make a backup before migrations when touching critical tables (automatic with migration tool).
  - After migration, compile and run a freshness check to validate (`cargo check` and app status call).
- CRITICAL: Always use environment variables for database access. NEVER use relative paths.
  - Use `DATABASE_URL` environment variable (preferred) or `DATABASE_PATH` as fallback
  - NEVER hardcode database paths like `"sqlite:src-tauri/db/stocks.db"` or `"sqlite:./db/stocks.db"`
  - Always check for environment variables first: `std::env::var("DATABASE_URL")` or `std::env::var("DATABASE_PATH")`
  - If environment variables are not set, return an error - do not use fallback paths

## Migration Rules (NON-NEGOTIABLE) - UPDATED SYSTEM
**‚ö†Ô∏è CRITICAL: We use a CUSTOM Rust migration tool, NOT sqlx directly!**

### Environment Setup (REQUIRED)
```bash
# ALWAYS set up environment first
export PROJECT_ROOT=/Users/yksoni/code/misc/rust-stocks
cd $PROJECT_ROOT/src-tauri
```

### Current Migration Commands
```bash
# Create new migration (creates both .up.sql and .down.sql)
cargo run --bin migrate -- create <description>

# Apply migrations
cargo run --bin migrate -- run

# Check migration status  
cargo run --bin migrate -- status

# Revert last migration
cargo run --bin migrate -- revert
```

### Database Admin Commands
```bash
# Check database status (ALWAYS run first)
cargo run --bin db_admin -- status

# Create manual backup
cargo run --bin db_admin -- backup

# Run migrations with safety checks (REQUIRES --confirm for production)
cargo run --bin db_admin -- migrate --confirm

# Verify data integrity
cargo run --bin db_admin -- verify
```

- CRITICAL: NEVER modify an applied migration file - this breaks checksum validation
- ALWAYS create new migrations using `cargo run --bin migrate -- create <description>`
- ALWAYS test migrations on a backup database first before production
- ALWAYS backup the database before running migrations on production data (automatic with tool)
- ALWAYS verify migration status with `cargo run --bin migrate -- status`
- ALWAYS use descriptive migration names that explain the change
- NEVER delete migration files once they've been applied to any database
- NEVER edit migration files after they've been applied (creates checksum mismatches)
- ALWAYS run `cargo run --bin migrate -- run` to apply new migrations in chronological order
- ALWAYS validate that all migrations are installed with `cargo run --bin migrate -- status`
- CRITICAL: ALWAYS set PROJECT_ROOT environment variable and run from src-tauri directory
- ALWAYS create reversible migrations (tool creates both .up.sql and .down.sql automatically)

## Key Migration Principles I Will Follow:
- NEVER modify migration files after creation
- NEVER manually apply migrations with sqlite3
- NEVER manually insert into migration tracking tables
- ALWAYS use the custom migration tool: `cargo run --bin migrate --`
- ALWAYS set PROJECT_ROOT environment variable before running migrations
- ALWAYS run from the correct directory: `$PROJECT_ROOT/src-tauri`
- ALWAYS fix issues properly, not bypass them

## API Contract Discipline (NON-NEGOTIABLE)
- NEVER modify backend function signatures without checking all frontend callers
- ALWAYS use consistent naming: `snake_case` in Rust, map to `camelCase` in frontend
- ALWAYS validate parameter names match between frontend invoke() and backend function
- ALWAYS verify return types match between frontend expectations and backend reality
- ALWAYS make database field names match API struct field names exactly
- NEVER use different field names between database schema and API models
- ALWAYS use proper serde mapping for camelCase conversion

## Testing Requirements
- ALWAYS run integration tests for API changes: `cargo test && cd src && npm test`
- NEVER claim something is "fixed" without testing the actual user flow
- ALWAYS test frontend-backend communication end-to-end

## Before Any API Change Checklist
- [ ] Check frontend API calls match backend function signatures
- [ ] Verify parameter names are consistent (startDate ‚Üí start_date mapping)
- [ ] Confirm return types match frontend expectations
- [ ] Test the actual user flow, not just unit tests
- [ ] Update TypeScript interfaces if backend structs change

## TypeScript Rules
- TS bindings: Do not create manual TS types for backend-shared structs. Use `ts-rs` generated bindings only.
- Generated files: Never edit files under `solid_frontend/src/api` (generated).
- CRITICAL: Always generate TypeScript bindings for frontend using ts-rs on Rust backend code.
  - Add `#[derive(TS)]` and `#[ts(export)]` to all structs used in API responses
  - Add structs to `types.rs` re-exports and `generate_bindings()` test
  - Run `cargo test ts_bindings_export_tests::generate_bindings` to generate TypeScript files
  - NEVER create manual TypeScript interfaces for backend structs

## Code Quality Rules (NON-NEGOTIABLE)
- ZERO WARNINGS POLICY: All code MUST compile with zero warnings.
  - NEVER leave unused imports, variables, fields, or functions
  - ALWAYS prefix unused items with underscore (_) if they must exist
  - ALWAYS remove dead code instead of commenting it out
  - ALWAYS fix useless comparisons and other compiler warnings
  - This applies to ALL code: main library, binaries, tests, examples
  - Run `cargo check` and `cargo test` to verify zero warnings before committing
  - Warnings are bad developer experience and indicate sloppy code

## NEVER DO THESE THINGS
- ‚ùå Look for database in ROOT - it's in `src-tauri/db/stocks.db`
- ‚ùå Put migrations in root - they belong in `src-tauri/db/migrations/`
- ‚ùå Confuse frontend (src/) with backend (src-tauri/src/)
- ‚ùå Create databases or migrations outside proper directories
- ‚ùå Change API contracts without checking both sides
- ‚ùå Use different field names between database and API models
- ‚ùå Run direct SQL commands against production database
- ‚ùå Use hardcoded database paths - always use DATABASE_URL or DATABASE_PATH environment variables
- ‚ùå Use relative paths like `"sqlite:./db/stocks.db"` or `"sqlite:src-tauri/db/stocks.db"` - use environment variables only
- ‚ùå Modify applied migration files - this breaks checksum validation and causes migration failures
- ‚ùå Edit migration files after they've been applied to any database
- ‚ùå Delete migration files once they've been applied
- ‚ùå Run migrations without backing up the database first
# Cursor Rules