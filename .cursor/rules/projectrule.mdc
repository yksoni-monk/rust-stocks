# Cursor Rules


## Project Structure Rules
- Working directory is ALWAYS ROOT: `/Users/yksoni/code/misc/rust-stocks`
- Frontend is in `src/` (SolidJS TypeScript components)
- Backend is in `src-tauri/src/` (Rust code)
- Database is in `src-tauri/db/stocks.db` (2.5GB PRODUCTION DATABASE)
- Migrations are in `src-tauri/db/migrations/`
- Backups are in `src-tauri/db/backups/`
- most project context is in .md files in 'context/'
- NEVER put .md files randomly in the project root - they belong in the context/ folder


## Database Rules
- CRITICAL: Database changes MUST use sqlx migrations only.
  - NEVER run direct SQL (ALTER TABLE/UPDATE/CREATE/DROP) against the DB from the terminal or ad-hoc scripts.
  - Use files under `db/migrations/` 
  - check context/database_migrations.md to fully understand the migrations feature
  - Make a backup before migrations when touching critical tables (use the existing `DatabaseManager::create_backup`).
  - After migration, compile and run a freshness check to validate (`cargo check` and app status call).
- CRITICAL: Always use environment variables for database access. NEVER use relative paths.
  - Use `DATABASE_URL` environment variable (preferred) or `DATABASE_PATH` as fallback
  - NEVER hardcode database paths like `"sqlite:src-tauri/db/stocks.db"` or `"sqlite:./db/stocks.db"`
  - Always check for environment variables first: `std::env::var("DATABASE_URL")` or `std::env::var("DATABASE_PATH")`
  - If environment variables are not set, return an error - do not use fallback paths

## Migration Rules (NON-NEGOTIABLE)
- CRITICAL: NEVER modify an applied migration file - this breaks checksum validation
- ALWAYS create new migrations for schema changes using `sqlx migrate add`
- ALWAYS test migrations on a backup database first before production
- ALWAYS backup the database before running migrations on production data
- ALWAYS verify migration status with `sqlx migrate info` before and after changes
- ALWAYS use descriptive migration names that explain the change
- NEVER delete migration files once they've been applied to any database
- NEVER edit migration files after they've been applied (creates checksum mismatches)
- ALWAYS run `sqlx migrate run` to apply new migrations in chronological order
- ALWAYS validate that all migrations are installed with `sqlx migrate info`
- CRITICAL: ALWAYS use `--source db/migrations` flag with sqlx commands
  - ALWAYS use: `sqlx migrate add --source db/migrations <description>`
  - ALWAYS use: `sqlx migrate run --source db/migrations --database-url "sqlite:db/stocks.db"`
  - ALWAYS use: `sqlx migrate info --source db/migrations --database-url "sqlite:db/stocks.db"`
  - NEVER run sqlx commands without the `--source db/migrations` flag
  - This prevents creating migrations in the wrong directory (`src-tauri/migrations/` vs `src-tauri/db/migrations/`)

## Key Migration Principles I Will Follow:
- NEVER modify migration files after creation
- NEVER manually apply migrations with sqlite3
- NEVER manually insert into _sqlx_migrations
- ALWAYS use sqlx migrate run
- ALWAYS fix issues properly, not bypass them

## API Contract Discipline (NON-NEGOTIABLE)
- NEVER modify backend function signatures without checking all frontend callers
- ALWAYS use consistent naming: `snake_case` in Rust, map to `camelCase` in frontend
- ALWAYS validate parameter names match between frontend invoke() and backend function
- ALWAYS verify return types match between frontend expectations and backend reality
- ALWAYS make database field names match API struct field names exactly
- NEVER use different field names between database schema and API models
- ALWAYS use proper serde mapping for camelCase conversion

## Testing Requirements
- ALWAYS run integration tests for API changes: `cargo test && cd src && npm test`
- NEVER claim something is "fixed" without testing the actual user flow
- ALWAYS test frontend-backend communication end-to-end

## Before Any API Change Checklist
- [ ] Check frontend API calls match backend function signatures
- [ ] Verify parameter names are consistent (startDate → start_date mapping)
- [ ] Confirm return types match frontend expectations
- [ ] Test the actual user flow, not just unit tests
- [ ] Update TypeScript interfaces if backend structs change

## TypeScript Rules
- TS bindings: Do not create manual TS types for backend-shared structs. Use `ts-rs` generated bindings only.
- Generated files: Never edit files under `solid_frontend/src/api` (generated).
- CRITICAL: Always generate TypeScript bindings for frontend using ts-rs on Rust backend code.
  - Add `#[derive(TS)]` and `#[ts(export)]` to all structs used in API responses
  - Add structs to `types.rs` re-exports and `generate_bindings()` test
  - Run `cargo test ts_bindings_export_tests::generate_bindings` to generate TypeScript files
  - NEVER create manual TypeScript interfaces for backend structs

## Code Quality Rules (NON-NEGOTIABLE)
- ZERO WARNINGS POLICY: All code MUST compile with zero warnings.
  - NEVER leave unused imports, variables, fields, or functions
  - ALWAYS prefix unused items with underscore (_) if they must exist
  - ALWAYS remove dead code instead of commenting it out
  - ALWAYS fix useless comparisons and other compiler warnings
  - This applies to ALL code: main library, binaries, tests, examples
  - Run `cargo check` and `cargo test` to verify zero warnings before committing
  - Warnings are bad developer experience and indicate sloppy code

## NEVER DO THESE THINGS
- ❌ Look for database in ROOT - it's in `src-tauri/db/stocks.db`
- ❌ Put migrations in root - they belong in `src-tauri/db/migrations/`
- ❌ Confuse frontend (src/) with backend (src-tauri/src/)
- ❌ Create databases or migrations outside proper directories
- ❌ Change API contracts without checking both sides
- ❌ Use different field names between database and API models
- ❌ Run direct SQL commands against production database
- ❌ Use hardcoded database paths - always use DATABASE_URL or DATABASE_PATH environment variables
- ❌ Use relative paths like `"sqlite:./db/stocks.db"` or `"sqlite:src-tauri/db/stocks.db"` - use environment variables only
- ❌ Modify applied migration files - this breaks checksum validation and causes migration failures
- ❌ Edit migration files after they've been applied to any database
- ❌ Delete migration files once they've been applied
- ❌ Run migrations without backing up the database first
# Cursor Rules